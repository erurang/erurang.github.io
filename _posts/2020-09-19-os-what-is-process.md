---
layout: post
title:  "프로세스의 구성요소와 상태와 IPC"
subtitle: "프로세스의 구성요소와 상태와 IPC"
categories: cs
tags: os
comments: true

---

## 프로세스의 구성 요소에 대해 알아보자.

프로세스는 총 4구역으로 나뉘어져있다.

```
-----
Stack
-----
Heap
-----
Data
// BSS
-----
Code(text)
-----
```

PC(프로그램카운터)가 한줄한줄 주소를 읽어보면서

1. text

일단 코드가 실행이 되면 text(code) 영역에 기계어로 코드가 담기고

프로그램이 시작되고 끝날때까지 메모리에 계속 담겨있다.

2. data

코드안의 변수들은 data영역에 들어간다.

프로그램이 시작되고 끝날때까지 메모리에 계속 담겨있다.

데이터영역안의 BSS에는 변수선언은 되었으나 초기화는 되지않은 변수가 저장된다.

3. stack

함수 호출과 관련된 변수들이 저장되는 영역

함수호출이 완료되면 소멸함 **즉. 메모리가 낭비되는 공간이 없음.**

**스택에 한계가 있어 한계를 초과하도록삽입할수 없음**

스택영역에 저장되는 함수호출 정보를 **스택프레임** 이라고함

프로그램이 자동으로 사용하는 **임시메모리**

메모리의 높은주소에서 낮은주소로 (밑으로) 할당됨. -->  **head 영역을 over하면 stack overflow라 칭함**

계산과정

함수가 호출되면 호출된 **return address**를 기억후에

**stack**영역에 들어가서 함수호출,함수안의 변수들이 실행(계산)이 되고 **return address**로 값을 반환한다.

함수의 **return address**를 저장해놓는 이유는 함수가 안에서 거듭되어 실행이 될때 어디서 오류가 낫는지 트랙킹을 할수있기 떄문이다.

4. heap

사용자가 직접 관리할수있는 영역

malloc을 통해서 메모리공간을 동적으로 할당하고 free를 통해 해제할수있음

메모리의 낮으주소에서 높은주소 방향으로 할당되므로 --> **heap이 stack영역을 넘으면 heap overflow라 칭함**

**프로그램에 필요한 개체의 개수나 크기를 알수없을때 heap영역을 사용함**

**heap을 할당함으로써 속도저하 heap을 해제함으로써 속도저하가 일어남**


## 콘텍스트 스위칭

프로세스끼리 변경이 일어날때 변경하는 것을 Context Switching이라고 한다.

프로세스를 변경시키면 우리는 변경되기 이전에 사용된 프로세스의 상태를 기억해야만 다시 프로세스가 변경되었을때 그 상태부터 다시 시작할수있다.

그래서 프로세스가 변경이 일어났을때 상태를 기억하기위해 PCB를 이용해 저장하게된다

## PCB(process controll block)

PC(Program Counter)에 마지막까지 실행되고 있던 코드의 주소값을 기억한다.

SP(Stack Pointer)에서는 마지막까지 실행되고있던 함수의 주소값을 기억한다.

PCB에는 아래와 같은 정보들이 저장된다.

1. Process ID
2. Process State (프로세스의 상태..)
3. PC adress(cpu register)
4. Scheduling info (스케줄링이 어떤것으로 이루어지고 있는지에 대한 정보..)
5. Memory Info (메모리 사용상태..)
6. accounting Info (cpu사용시간.. 계정정보..)

## 프로세스간에 소통을 할때에 사용하는 IPC (Inter Process communication)

다른 프로세스가 내 프로세스 공간을 침범하여 영향을 주지 못하도록 IPC 기법을 사용한다.

예를들어 이해해보자.

```
PA
1~200
```

만약에 우리가 하나의 프로세스에서 1개를 세는데 1초가 걸린다고 하고, 200개를 세어야 한다면 200초가 걸리는 것을 알수있다.

이것을 프로세스 통신을 통해서 100초로 줄이면 어떨까?

```
PA
1~100

            File.txt
            
PB
101~200
```

프로세스A 와 B에서 같은 파일을 참조하여 각 프로세스에서 역할을 담당하여 100초로 줄이게 되었다.

여기서 하나 짚을수 있는 문제는.. 우리가 이전에 배웠던 유저모드 <-> 커널모드 를 통한 시스템콜을 기억해보면

위의 각 프로세스마다 우리는 같은 파일을 참조하기위해 유저모드에서 커널모드로 변경하고 프로세스 상태를 대기(블럭)상태로 변경하고

인터럽트를 통해서 대기상태가 끝낫다(파일을 읽었다)고 CPU에 알리고, 상태를 대기상태에서 준비상태로 변경시키고

인터럽트가 다시 실행가능하다고 CPU에 알리고 프로세스 상태를 실행가능 -> 실행 상태로 옮기고..

과정이 너무길고 시간이 너무 길어진다는걸 알수있다.

이런 과정을 줄이기위해 우리는 CPU의 공용공간인 kernal공간을 사용하기로 하였다.

### ICP의 여러 기법

프로세스는 3gb의 유저모드와 1gb의 커널모드로 이루어져있다.

```
User
User
User
----
kernal
```

프로세스끼리 공유되는 커널영역을 통해 위의 시간을 줄이기로한다.

1. File (유저모드)
2. Message Queue (아래부터 커널모드)
3. Shared Memory
4. Pipe
5. Signal
6. Semaphore
7. Socket
8. ... 

등등 다양한 방법이 존재한다.

## 정리

여러 프로세스들을 동시에 실행하여 성능 개선을 시킨다. (프로세스간의 통신방법 IPC를 사용)

File을 읽어오는 시간이 길기때문에 커널영역인 2~7번으로 성능개선 방법 시킨다.