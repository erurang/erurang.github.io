---
layout: post
title:  "mytube 마무리하며 느낀점"
subtitle: "mytube 마무리하며 느낀점"
categories: project
tags: mytube
comments: true

---

## 마무리

모든 소스코드는 깃허브 [Mytube](https://github.com/erurang/mytube)에 올려두었다.

이걸 왜 만들기 시작한거야?
--

나는 나중에 햇제! 라는 사이트를 하나 정말 제대로 구상해보고싶었다.

요새는 주식(코인)을 안하는 사람이 없는데.. 그래서 주식을 사라고! 또는 팔라고! 햇을때 주식이란게..

사람들이 오르면 사라했제~ 내리면 팔라했재~ 하면서 사람들을 놀리거나 하는 경우가 많더라

이걸 왠지 웹사이트로 만들어서 랭킹화시키면 되게 많은 사람들이 이용할거같더라고.. 

근데 그러려고보니 난 웹사이트에 대해 아는게 하나도없었고 (할줄아는건 파이썬..으로 알고리즘풀기...ㅠ)

내가 어떤 언어를 하나 잡아서 뭘 만들어본 경험이 한번도 없엇다. (물론 공부를 본격적으로 시작한건 2020년 7월..?~9월? 거의 그 수준)

대기업에 가려면 코딩테스트를 통과해야하는데.. 다른 cs과목들도 혼자서 공부하고 알고리즘도 하고 그러다보니깐 뭘 만든다는 생각도 못해봤다.

근데 딱 머리에 생각난게 저거여서 그래서 이걸 만들려면 어떤언어가 필요한지.. 찾아보고 공부하고 .. 

일단 친구가 프론트가 사람이 되게 부족하다고. 그러니 html과 Css를 edwith란 사이트에서 공부했는데

되게 좋더라. 역시 내가 꼭 가고싶은 기업이다.. 네이버는 꼭 간다.. 그 후에 자바스크립트 문법도 혼자서 공부하게됬다.

그래서 일단 가장 흔한 유튜브를 한번 내가 만들수있으면 좋겠다는 생각을 했다. 제작기간은 총 2020-12-13 ~ 29으로

2주가 걸렸고, 만드는 과정에서 자바스크립트와 노드에 대해서 너무나 잘 배우게됬고

그 사이사이 한 기술이 있을때 그 기술을 보완하기위해 나온 기술이 뒤이어 계속나온다는점이 신기했다.

첫구상
--

처음에는 게시판이라도 하나 만들어보고싶었다. 게시판을 만들줄 알아야 글을쓰던말던 할거아닌가.

게시판을 만들려면? 데이터베이스를 뭘쓸지도 문제였지만 젤 우선적으로 필요한건 **서버**였다.

서버를 구성하는 여러가지 언어가 있었다. 할줄아는게 파이썬밖에 없었기에 파이썬으로 서버를 만들려면 Django 프레임워크가 있었는데

한국에선 장고를 쓰는 회사도 적고.. 모든 프론트엔드 생태계는 자바스크립트로 이루어져 있다더라. 그래서 무턱대고 자바스크립트를 하기로했다. 공부는덤

Node.js 첫 사용
--

node에는 npm이라는 패키지 매니저가있는데 (사람들이 만들어놓은 모듈을 모아논 사이트) 라고 생각하면 편할거같다.

Npm과 같은기능을 하지만 보안과 속도를 조금더 높여준게 페이스북에서 만든 yarn이라는게 있는데

나는 이번에 npm을 이용했다.

노드js를 이용하려다보니 (자바스크립트) ES라고 불리는 언어문법이 있었고 이를 적용하려면 **babel**이라는 불리는 모듈이 필요했다.

이건 우리가 코딩을할때 ES 최신문법을 사용하게 해주고 브라우저는 구식언어로 알아먹게 도와주는 참으로 필수적인 놈이였다.

node.js의 express를 이용하여 서버를 바로 구성할수 있었고, router를 이용해 각 url을 관리할수있었다.

MVC 패턴?
--
가장 중요했던 부분은 **MVC패턴인데 model views controller 를 각각의 기능별로 나누는것이다.**

model은 데이터베이스 (나는 몽고디비를 이용했다.) 
views는 보이는화면 (node에선 Pug 템플릿을 제공한다) 
controller는 라우터에서 연결된 모든 기능들을 관리하도록

**모든 기능들을 하나씩 나눈다.** 처음에는 대체 이걸 왜 하나하나 나누지? 불편하게.. 했었는데..

나중에 기능별로 나눈다는건 진짜 잘나누면 엄청 편하다고 느꼇다..

물론 한파일에 모든것을 다 적을수는 있다. 하지만 그렇게한다면 코드가 몇천줄만 되어도 어디에 어떤게 있는지 알수가없다

이 작은 프로젝트를 한 내 경험에도 느끼는데 나중에 코드가 몇만줄이 간다면?? 어우.... 

백엔드 작업은 최대한 나눠가면서 작업하니깐 이놈은 로그인 이놈은 로그아웃. 등등 코드를 보면 바로 파악해서 

똑같은 코드를 이용해서 다른코드를 쓸때 원하는 코드를 찾고 그걸 보완할때도 상당히 편했는데..

css하는 과정이 귀찮아서;; (사실.. 2주간 미친듯이 밤새가며 붙잡고있었더니 지친게 컷음) 그래서 id나 class를 남발했더니

같은 형식으로 css로 표시해서 같은화면을 보여줘야할떄도 어디에 어떻게 뭘 적용한지 보고도 헷갈리니깐 시간은 몇배로 더걸리고.. 더지쳤다..

같은 코드를 똑같이 다른 클래스에 보고 적용해야하고.. 이거덕에 진짜 코드를 처음 쓸때부터 나중에 재활용이 가능하다는 생각으로

하나하나 섬세히 코드를 구상해야 한다는걸 정말 뼈아프게 느꼈다.

MVC 패턴중의 하나 Model
-- 

게시판을 하나 만들기위해서 데이터베이스를 관리해주는게 필요했는데

Nosql과 sql로 나뉘어져있었다. sql은 규칙이 엄격하다(만든 스키마에 추가가 안됨) nosql은 규칙이 덜엄격하다 로 나뉘어졌었다.

자바스크립트엔 몽고디비(nosql)을 이용할수있게 mongoose라는 모듈이 있었고 몽구스를 이용해 각 스키마를 만들어서

데이터베이스를 이용하는것을 또 배우게 됬다. 데이터베이스를 만들때 type(넘버 스트링 오브젝트..)을 지정해주고

이게 어떤 데이터베이스와 연관이 있으면 type을 objectid로 지정해두면 나중에 다른 연관된 다른 모델에서 사용할떄

populate()를 사용하면 거기 모델의 정보도 얻어와서 사용가능하다는게 참 좋은거같았다.

그리고 우리가 데이터베이스를 사용한후에는 save()를 이용해 적용된것을 몽고에 알려줘야한다.

MVC 패턴중의 둘 views
--

views는 html같이 보이는 부분을 처리하는것이다. 이제 노드에서는 html보다 더 쓰기 편한

PUG라는 템플릿을 사용할수있다. 솔직히 pug는 이제 마스터한거같다..

Pug로는 if같은것도 쓸수있고 나중에 렌더를 시킬때 필요한 데이터를 넘겨주면

pug안에서 변수로 사용이 가능하다. 그리고 pug에는 include와 mixin 기능이 존재하는데

include는 각 템플릿을 끌어가져와서 적용한다 그래서 main템플릿을 하나 만들어놓고

나머지 바뀌는 부분만 include로 처리를하면된다. 

mixin은 함수처럼 작동하는데 +함수명({변수지정}) 이렇게 해주면 예를들어 내가 어떤화면에서

ㅁ 를 쓰는데 다른화면에서도 ㅁ를 똑같이 써야할때가 온다. 그러면 minxin으로 만들어서

중복적으로 코드를 적지않아도 되도록 도와준다. 

정말 html보다 안편할래야 안편할수가 없는 템플릿이다.

MVC 패턴중의 셋 controllers
--

기능을 담당하는 컨트롤러이다. 나는 만들때 라우터(url)을 따로 관리햇는데

url마다 필요한 기능이 다르니깐 컨트롤러를 따로두어 연결을했다.

정말 하나하나 기능을 나눠서 적용한다는게 정말 편하고 좋다는걸 또 느꼇고

이 컨트롤러가 res(응답) 을 render로 views의 pug템플릿을 넘겨주고 사용자에게 보이게 도와준다.


req,res에 대해
--

req,res는 요청과 응답인데 요청을할때는 post 응답을 받아올때는 get이라 생각하면된다

그러니깐 사용자가 로그인이나 뭐.. 그런 서버로 보내야만하는 거는 포스트

겟은 서버로부터 사용자에게 주는거라 보면된다. (홈페이지로 접속할때.. 등등)

포스트와 겟은 Form의 method에서도 차이가 있는데 각 형식을 어떻게 지정하느냐에 따라서

url에 정보를 남기냐 안남기냐로 처리를하고. 그 url에 정보를 남김으로써 우리가 

req에서 정보를 얻어와 변수로 이용이 가능했다

물론 이것을 받아와 사용하기 위해 body-parser 모듈이 필요했다.

middleware
--

미들웨어는 거치는 함수? 느낌으로 볼수있는데 전역적으로 로컬에 변수선언도 가능하고

이걸 사용하는 이유는 도중에 정보를 가로챌수도있고 정보를 추가할수도있고

되게 다방면으로 가능하다.

미들웨어는 사용된후 그뒤에 사용될곳에 미들웨어의 값들을 그대로 사용이 가능하다.

next()를 써주어 다음으로 넘길수있다.

async await 비동기적 처리
--

비동기적으로 처리한다는것은 코드가 순차적으로 실행될때 어떤 코드는 시간이 걸리는데

이 코드가 결과를 주는걸 기다려달라고 말한후 다른 코드를 또 실행하게 해준다.

그런데 내가 친구한테 얼핏듣기로 자바스크립트는 싱글쓰레드 언어라고 들었다.

쓰레드가 여러개있으면 사람이 여럿이 있듯이 일을 나눠서 할수있는 개념이다

근데 자바스크립트가 싱글쓰레든데 어떻게 비동기적 처리가 가능한것일까?

하는 생각도 들더라. 즉 자바스크립트 엔진이 어떻게 작동하는지 알아야한다. 

이 개념은 javascript란에 정리해두었다.


로그인 로그아웃을 구현하면서
--

자 이제 로그인 로그아웃을 구현할 때가 왔다.

모델에서 몽구스로 유저의 스키마를 만들어서 가입을 받는식으로 했다.

자 가입을하고 새로고침을 했더니? 로그인이 풀려있는것이다.. 

뭐지 몽고디비에는 사용자가 있는데? 이게 왜그럴까?

이런걸또 알아보니깐 하나하나 또 찾아보게되더라. http는 stateless라서 그렇다.

자체적으로 상태를 저장을 하지 못한다는거다. 그래서 이걸 저장하게해주려면 뭐가필요한가?

여기서 쿠키와 세션이 또 등장한다. 세션은 서버가 중요한 자료를 들고있고

쿠키는 마치 인증서 같은느낌? 

몽고디비를 아마존을 외부에?
--

서버를 배포할때는 내 몽고디비에 데이터를 남겨둘순 없었다.

그럼 외부에 내 데이터를 관리해줄게 필요했는데 그걸 대신해주는게

mongo atlas라는게 있었다. 내 외부 데이터베이스 서버라고 보면될듯

그리고 아마존에는 내 파일들을 올릴수있는 버킷(s3)가 있었다.

자바스크립트의 한계?
--

이걸 다 만들어보면서 느낀게있었다.

나는 일단 단순히 프론트엔드는 리액트가 필수래. 하고 대충 문법부터 다 배웟었다.

물론 사용은 파이썬만 했다. 자바스크립트와 리액트의 문법은 대충 알고있었다.

하지만 그 **철학**을 몰랐다. 이게 왜 생겼는지 왜 생겨야만했는지.

그런데 이번 프로젝트를하면서 왜 생겼는지 왜 생겨야만했는지 알겠더라.

자바스크립트는 axios(fetch)을 이용해 비동기적으로 서버와 데이터 교환이 가능하다.

하지만 그 데이타를 서버에서 처리할수만 있을뿐.. 그게 화면에 렌더가 되진 않는다.

이번에 자바스크립트로 프로젝트를 만들어보면서 만든 기능이 댓글을 생성/수정/삭제 좋아요/싫어요

구현을 했다. axios를 이용해서. 그런데 실시간으로 반영이 되지않더라.

즉 서버로부터 처리(반영)된 부분이 화면에 보이려면 다시 모든 화면의 요소가 다시 렌더됬어야했다.

모든 부분을 렌더한다? 그것은 정말 좋지않다는것이다.

**자바스크립트의 한계는 이거다. 데이터가 처리된 후 이걸 다시 표현하려면 화면이 다시 렌더되야한다.**

난 이게 당연한줄알았다. 모든 웹사이트에서 이렇게 써왔으니깐. 이게 왜 안되는거지?? 하고 생각이 자연스레 들더라.

물론 자바스크립트에서도 눈속임으로 DOM을 이용해 사라지고 수정되고 눈에 바로 보이게끔은 만들수있다. 이 프로젝트에서도 그렇게 했고..

화면이 다시 렌더가 된다는건 바뀔필요가없는 화면까지 불필요하게 바뀌어야하고 (새로고침되듯이)

그럼 그만큼 로딩시간도 길고 데이터소모도 크고 쓸데없는일을 하게 된다.

그래서 나오게된 기술이 SPA(single page application) 이라는 기술인데

**비동기적으로 서버와 통신해서 필요한 부분만 렌더해주는것이다.**

이걸 이용한 언어가 React Angular Vue 이다. 이 프로젝트가 끝난후

나는 리액트 앵귤러 뷰가 왜 생겼는지 알게되었다. 자바스크립트로 하면서도

아 이건 리액트로 이렇게하면 되게 편하게 됬었는데.. 하고 문법만 알던 나도 이런 생각을했는데

리액트가 왜 생겼는지 이번에 확실히깨달았다.

이젠 리액트를 공부를 할것이다. 근데 리액트에는 상태관리하는 걸로 Redux라는게 있더라.

이게 왜 나오게 됫을까? 하는 생각도 다음 다른 어떤 프로젝트를 해보면서 또 그 배경을 파악해보고

리액트 언어로 나를 발전시키기 위해 공부할것이다.

이 프로젝트를 만들면서 공부하게된점 / 배운점은 모두 web/javascript 와 project/wetube에 정리되어있다.