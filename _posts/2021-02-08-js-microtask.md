---
layout: post
title:  "웹의 전체적 구동과정"
subtitle: "웹의 전체적 구동과정"
categories: antique
tags: antique
comments: true

---

[이전글](https://erurang.github.io/web/2021/02/03/js-pro-thread/)을 보고 이 글을 읽으면 도움됩니다.

이전글에선 web API에서 사용하는 setTimeOut callback과 click Callback..이 task Queue에서 처리된다고 배웠다.

이번엔 자바스크립트와 웹이 전체적으로 어떻게 작동하는지 보자.

WEB API에는 화면이 만들어지는 과정의 Render와 async/promise를 처리하는 Microtask queue와 콜백을 관리하는 task Queue

그리고 자바스크립트에서 관리하는 콜스택과 메모리힙이 있다고 하였다.

또한 이것을 관리하기위한 이벤트루프 라는것이 있다고 하였다.

여기서부터 이벤트루프가 계속 돌면서 처리되는 과정을 적는다.

1. task Queue에서 처리되기 기다리는 콜백들이 있음.
2. 이벤트 루프가 확인후에 자바스크립트의 콜스택으로 옮김
   1. 하지만 이벤트루프가 확인했을때 있었던 콜백만 콜스택으로 옮겨 처리하고 후에 들어오는 콜백들은 다음루프때 처리하기위해 남겨둠
3. task Queue에서 javascript의 콜스택으로 옮겨진 과정이 다 끝나면 이벤트루트는 Render를 확인함
   1. 렌더에서는 사용자의 유연한 사용경험을위해 초당 60fps(17ms) 안에 처리되야함.
4. Render를 확인하고 화면이 그림.
5. microtask Queue를 확인함. 여기서는 프로미스/에이싱크 등이 처리가됨
   1. 여기서는 task Queue와 다르게 마이크로테스크 큐가 0이 될때까지 새로들어오는 것까지 모두 콜스택으로 옮겨 처리함
6. 마이크로태스크큐의 모든 과정이 끝났다면 다시 콜스택을 보기를 반복함..

이렇게 이벤트루프는 계속 돌면서 처리하는데 이제 초당 60fps를 표현하기위해 우리는 17ms안으로 일들을 처리해야된다는걸 알수있음.

마이크로테스크큐에서 또는 테스크큐에서 17ms이상의 일이 걸리게되면 이벤트루프는 Render로 넘어가지못하여 화면을 그리지못하고

화면이 사용자에게 나타나는 과정에 유연하지못하게된다.

