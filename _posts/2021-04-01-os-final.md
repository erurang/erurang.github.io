---
layout: post
title:  "운영체제란? System Call"
subtitle: "운영체제란? System Call"
categories: cs
tags: os
comments: true

---

### 운영체제란?

시스템자원을 효율적으로 분배하기위해 하드웨어와 프로그램을 조작함

### 시분할시스템 (멀티테스킹)

멀티테스킹 : 단일 CPU에서 여러 응용 프로그램의 병렬실행을 가능하게 함

### 프로세스

프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU 의 할당을 받을 수 있는 것을 말한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 총칭하여 프로세스라고 한다. 


### 프로세스 상태

running - CPU에서 실행중인 상태

ready - CPU에서 실행대기 상태

block(waiting) - 특정 이벤트 발생 대기 상태 (저장매체 -> 파일읽기.. 프린트 -> 프린트끝남)
```
프로세스 생성(new) -> 실행가능(ready) -> 실행중(running) -> 종료(exit)
                        -> 대기(block) <- 
```

### 프로세스 스케쥴러

프로세스를 스케줄링 하기위한 Queue

- Job Queue : 현재 시스템 내의 모든 프로세스의 집합
- Ready Queue : 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
- Device Queue : Device I/O 작업을 대기하고있는 프로세스의 집합

각각의 Queue에 프로세스를 넣고 빼는 스케쥴러에도 3가지 종류가 존재함.

- 장기스케쥴러(Long-term scheduler or job scheduler)
  - 특징
    - 메모리는 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우에 대용량 메모리(일반적으로 디스크)에 임시로 저장된다.
    - 이 pool에 저장되어있는 프로세스중 어떤 프로세스에 메모리를 할당해서 ready queue로 보낼지 결정하는 역할을 한다
  - 정리
    - 메모리와 디스크 사이의 스케줄링 담당
    - 프로세스에 memory(각종 리소스)를 할당
    - 실행중인 프로세스의 수 제어
    - 프로세스의 상태를 new -> ready 로 변경

- 단기 스케쥴러(Short-term scheduler or CPU scheduler)
  - 특징
    - CPU와 메모리 사이의 스케쥴링을 담당
    - Ready queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정
    - 프로세스에 CPU를 할당
    - 프로세스 상태를 ready -> running -> block(waiting) -> ready 로 변경

- 중기 스케쥴러(Medium-term scheduler or Swapper) 
  - 특징
    - 여유공간 마련을 위해 프로세스를 통째로 디스크로 쫒아냄 (swapping)
    - 프로세스에게서 메모리를 deallocate(할당해제함)
    - 실행중인 프로세스의 수를 제어
    - 현 시스템에서 메모리에 많은 프로그램이 동시에 올라가는것을 조절하는 스케쥴러
    - 프로세스상태를 ready -> suspended
  - suspended 상태?
    - 외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 상태를 의미하여 프로세스를 전부 디스크로 보낸다
    - 외부적인 이유로 메모리 밖으로 보내졋기 때문에 스스로 ready state로 돌아갈수없음.
      - block 상태와의 차이점은 block은 다른 수행작업을 기다리는 상태여서 수행이 끝난후 ready state로 돌아갈수있음


### CPU 스케쥴러

프로세스를 어느 순서대로 실행할까?

스케줄링 대상은 Ready Queue 에 있는 프로세스들이다.

- 선점형 스케쥴러
  - 하나의 프로세스가 다른 프로세스 대신에 CPU를 사용할수 있음

- 비선점형 스케쥴러
  - 하나의 프로세스가 다른 프로세스 대신에 CPU를 사용할수 없음

- First In First Out (선입선출)
  - 특징
    - 비선점형(Non-Preemptive) 스케줄링
    - 일단 CPU 를 잡으면 CPU burst 가 완료될 때까지 CPU 를 반환하지 않고 할당되었던 CPU 가 반환될 때만 스케줄링이 이루어진다.
  - 단점
    - 소요시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상이 발생한다.


- Shortest Job First (짧은 실행시간 먼저)
  - 특징
    - 비선점형(Non-Preemptive) 스케줄링
    - 다른 프로세스가 먼저 도착했어도 CPU burst time 이 짧은 프로세스에게 선 할당
  - 단점
    - 효율성을 추구하는게 가장 중요하지만 특정 프로세스가 지나치게 차별받으면 안되는 것이다. 이 스케줄링은 극단적으로 CPU 사용이 짧은 job 을 선호한다. 
    - 그래서 사용 시간이 긴 프로세스는 거의 영원히 CPU 를 할당받을 수 없다.

- Priority (우선순위)
  - 특징
    - 우선순위가 가장 높은 프로세스에게 CPU 를 할당하는 스케줄링이다. 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높다.
    - 선점형 스케줄링(Preemptive) 방식 
    - 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점한다.
  - 단점
    - 실행 준비는 되어있으나 CPU 를 사용못하는 프로세스를 CPU 가 무기한 대기하는 상태(aging)
  - 해결책
    - 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주자.


- Round Robin 
  - 특징
    - 현대적인 CPU 스케줄링
    - 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.
    - 할당 시간이 지나면 프로세스는 선점당하고 ready queue 의 제일 뒤에 가서 다시 줄을 선다.
    - RR은 CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
    - RR이 가능한 이유는 프로세스의 context 를 save 할 수 있기 때문이다.
  - 장점
    - Response time이 빨라진다.
    - n 개의 프로세스가 ready queue 에 있고 할당시간이 q(time quantum)인 경우 각 프로세스는 q 단위로 CPU 시간의 1/n 을 얻는다. 즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
    - 프로세스가 기다리는 시간이 CPU 를 사용할 만큼 증가한다. 공정한 스케줄링이라고 할 수 있다.
  - 단점
    - 설정한 time quantum이 너무 커지면 FCFS와 같아진다. 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch 로 overhead 가 발생한다. 그렇기 때문에 적당한 time quantum을 설정하는 것이 중요하다.
