---
layout: post
title:  "가상메모리와 페이징시스템 교체 알고리즘"
subtitle: "가상메모리와 페이징시스템 교체 알고리즘"
categories: cs
tags: os
comments: true

---

## 가상메모리란?

메모리란? [https://www.youtube.com/embed/dgMeWRy84l8](https://www.youtube.com/embed/dgMeWRy84l8)

가상메모리는 물리메모리의 크기 한계를 극복하기 위한 기술이라고 할수있다.

하나의 프로세스는 늘 4GB를 가지는데 (3gb 유저 1gb 커널) 우리의 물리메모리가 6gb라고 해보자.

우리는 프로세스 2개를 동시에 돌리고싶지만 메모리 용량의 한계때문에 우리는 2개의 프로세스를 사용하지 못하게된다.

물리메모리보다 큰 프로세스를 사용하기위해 나온 기술로써 프로세스전체를 메모리에 올리는것이 아닌 필요한(사용하는) 부분만 메모리에 올려

여러 프로세스를 사용가능하게 하는 기술을 가상메모리라고 한다.

## 메모리를 나누는 기술

물리메모리를 나누기위한 기술에는 페이징 방법과 세그멘트 방법이 존재한다.

페이징 방법은 프로세스를 운영체제마다 정해진 크기 (4kb ... )로 잘라서 페이지 테이블에 기록해둔다.

세그멘테이션 방법은 크기가 다른 단위인 세그멘트로 분할한다.

## 페이징 방법과 세그멘테이션의 차이


## 페이지 테이블이 사용되는 그림

세그멘테이션/페이징 둘다 컴퓨터가 메인메모리를 사용하기 위해 보조기억장치로부터 데이터를 저장하고 검색하는 메모리 관리기법이다.

![스크린샷 2022-01-25 오후 4 14 08](https://user-images.githubusercontent.com/56789064/150928842-a8a643df-a313-4421-954b-b16c39a0e80e.png)

논리 메모리를 페이징 단위로 나누어 페이지 테이블을 통해 물리 메모리에 올린다.

이 페이지 테이블은 프로세스 각 영역을 페이지로 나눠 페이지의 묶음을 가지고있고, 물리 메모리에 현재 이 페이지테이블이 Valid,invalid 한지 기록되어있다.

## 선행페이징

프로세스 전체를 메모리에 올려놓는것을 선행페이징 이라고한다.

## 요구페이징

당장 CPU를 쓰는 곳만 메모리에 적재하는 방식이다.

CPU가 해당 페이지를 요구할 때까지 그 페이지를 메모리에 올리지 않는 방식으로 (즉, 한번도 접근되지 않는 페이지는 물리 메모리에 전혀 적재되지 않는다)

페이지 부재(page fault)가 발생하면 그 때 트랩을 걸어 해당 페이지를 메모리에 적재한다.

## 페이지 폴트(page fault)

물리 메모리에 페이지가 존재하지않을때 메모리에 페이지를 올리고 재 실행하는 인터럽트를 페이지폴트 라고 한다.

CPU가 메모리를 요청시에 일어나는 방식을 알아보자

MMU(Memory Management Unit)는 CPU가 메모리에 접근하는 것을 관리(가상 <--> 물리)하는 컴퓨터 하드웨어 부품이다. 

TLB는 변경된 주소를 캐싱하는 곳이다

```
              TLB
               |
               | (2)
               |
CPU ==(1)==>  MMU ==(3)==> [Page A`s Table] => invalid ? => OS =====> Process A`s page
                           [Update A`s Page] <==============================

                                            => valid ?
  <======================  [A Page] <=======
```

1. CPU가 가상주소로 데이터를 요청하고
2. MMU에서 가상메모리 주소를 물리메모리 주소로 변환시킨다.
3. 가상 <-> 물리 주소로 변환시킨 주소가 TLB에 캐싱되어있다면 메모리에서 CPU로 데이터를 넘겨준후 끝낸다. 없다면 TLB에 캐싱을 해두고 다음 단계로 넘어간다.
4. Page Table을 통해 메모리에 CPU가 요청한 주소가 올라가있는지(valid, invalid) 확인한다.
5. valid 하다면 요청한 Page를 CPU에 넘겨준다.
6. invalid 하다면 OS는 해당 프로세스를 대기상태로 만든후 요구된 페이지를 찾아 메모리에 적재
7. 다시 프로세스를 실행시켜 작업을 재실행한다.

메모리에 부분적으로 적재된다면, 프로그램의 크기가 물리적인 메모리공간 용량과 무관하게 되어 많은 프로그램이 메모리를 공유하여 CPU 사용률을 높일수 있다.

그리고 이렇게 메모리에 적재되는 과정(페이지폴트)을 줄이는것이 성능향상의 비결이라고 할수있다.

## 무엇을 기준으로 메모리를 변경시킬것인가?

만약에 부분적으로 올린 메모리도 꽉찬다면? 이떄는 어떻게 새로운 프로세스를 메모리에 적재할까? 이에대한 교체 알고리즘이 필요할것이다.

## 페이지 교체정책 알고리즘

1. FIFO

가장 먼저 올라간 페이지를 바꾼다.

2. OPT

앞으로 사용하지않을것 같은 페이지를 바꾼다. (기본 OS에서는 우리가 어떤것을 사용할지 말지 컴퓨터는 알지못하므로 불가함..)

3. LRU (가장 많이 사용됨)

가장 오래전에 사용된 페이지를 바꾼다.

4. LFU

가장 적게 사용된 페이지를 바꾼다.

5. NUR

각 페이지마다 참조/수정 (0,0) 비트를 두어 (0,0) (0,1) (1,0) (1,1) 순으로 페이지를 바꾼다.

## 페이지 폴트가 자주일어나면?

페이징 폴트가 자주 일어나게 되면 메모리에 올라가고 실행되기도전에 다시 페이지폴트가 일어나고.. 이 과정의 반복으로 CPU는 어떤 응용프로그램도 실행하지 못하게 된다.

이 상태를 **쓰레싱** 이라고 한다.

## 페이징과 세그멘테이션의 단점

페이지는 정해진 크기로 무조건 페이지테이블을 나눠야하기 때문에, 4kb로 페이지를 나눈다고 하고, 9kb의 페이징이 이루어질때 12kb의 페이지를 만들어야하기때문에

3kb의 빈 공간이 남게된다. 이것을 **내부단편화** 라고한다.

세그멘테이션은 메모리에 올라갈 크기는 제한이 없지만 메모리에 연속된 공간이 올라가야하기때문에 물리메모리에 세그멘테이션을 올릴 연속된공간이 없을수도있다.

이것을 **외부단편화** 라고한다.