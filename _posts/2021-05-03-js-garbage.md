---
layout: post
title:  "가비지 컬렉터와 메모리관리"
subtitle: "가비지 컬렉터와 메모리관리"
categories: web
tags: javascript
comments: true

---

### 자바스크립트는 어떻게 메모리 관리를 할까?

C언어에서는 malloc free로 동적메모리를 지정하고 해제하는 방법이 있었다.

자바스크립트에서는 자료형도 지정하지않는데 어떻게 메모리를 지정하고 해제할까?

가비지 컬렉터를 이용한다.

### 가비지 컬렉터란?

우리가 선언하는 모든것은 메모리를 참조한다. 그래서 선언해도 사용하지(되지)않는 것들을 찾아서 메모리를 관리하는데,

"도달가능성" 이라는 개념을 사용한다. 여기서 도달가능성이란 일정 값에 참조를 한다라고 생각하면 된다.

```
1====
let user = {
    name: 'hi'
}

2====
let admin = user

3===
user = none
```

1번에서 우리는 user라는 객체를 생성했다. 그리고 2번에서 admin이라는 변수를 만들어 user를 참조하게 만들었다.

2번까지만 봤을때 우리는 user에 도달가능하다. 라고 판단한다. 그래서 가비지 컬렉터는 이 값을 메모리에서 제거하지않는다.

하지만 3번에서 none으로 user를 재할당하게되면 2번의 admin이 참조하는 user값은 none으로 바뀌어버린다.

그럼 1번 user에서 선언된 값들에는 참조가 불가능하게된다. 그래서 가비지 컬렉터는 이 값을 메모리에서 제거한다.

### 내부 동작알고리즘 (Mark and sweep)

가비지컬렉터가 참조하여 메모리를 삭제하는 알고리즘중 한가지 방법이다.

1. 가비지 컬렉터가 가장상위에 있는 root정보를 수집하고 mark(기억) 한다.
2. 그 루트가 참조하고있는 (내부값) 들을 mark한다.
3. 2번을 계속 반복하여 도달가능한 모든 객체를 모두 mark한다
4. mark되지않은 객체를 메모리에서 모두 제거한다.


### 그럼 가비지컬렉터는 매번 실행이 될까?

가비지컬렉터는 웹성능에 영향을 끼치지 않도록 최적화기법이 적용되있다.

세대별 수집 
    – 객체를 '새로운 객체’와 '오래된 객체’로 나눈다. 객체 상당수는 생성 이후 제 역할을 빠르게 수행해 금방 쓸모가 없어지는데, 이런 객체를 '새로운 객체’로 구분합니다. 
    - 가비지 컬렉터는 이런 객체를 공격적으로 메모리에서 제거합니다. 일정 시간 이상 동안 살아남은 객체는 '오래된 객체’로 분류하고, 가비지 컬렉터가 덜 감시합니다.

점진적 수집 
    – 방문해야 할 객체가 많다면 모든 객체를 한 번에 방문하고 mark 하는데 상당한 시간이 소모됩니다. 
    - 가비지 컬렉션에 많은 리소스가 사용되어 실행 속도도 눈에 띄게 느려지겠죠. 
    - 자바스크립트 엔진은 이런 현상을 개선하기 위해 가비지 컬렉션을 여러 부분으로 분리한 다음, 각 부분을 별도로 수행합니다. 
    - 작업을 분리하고, 변경 사항을 추적하는 데 추가 작업이 필요하긴 하지만, 긴 지연을 짧은 지연 여러 개로 분산시킬 수 있다는 장점이 있습니다.

유휴 시간 수집 
    – 가비지 컬렉터는 실행에 주는 영향을 최소화하기 위해 CPU가 유휴 상태일 때에만 가비지 컬렉션을 실행합니다.