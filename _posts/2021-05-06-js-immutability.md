---
layout: post
title:  "불변성(immutability)이 무엇일까??"
subtitle: "불변성(immutability)이 무엇일까??"
categories: web
tags: javascript
comments: true

---

### 불변성이 대체 무엇일까?

redux를 사용하거나, react를 사용을 해보았다면 분명 한번쯤은 기존 데이터를 변경하면 안되고 

불변성을 지켜주어야한다. 는 말을 들어본적이 있을것이다.

리액트와 리덕스 둘다 성능을 높이기 위해 shallow comparison을 사용하기 때문이다.

deep 과 shallow 한글로 얕은 비교 깊은비교로 볼수있는데, 한 문장으로 말해서 shallow는

겉의 메모리주소가 다르면 다르다고 판단하고 갱신, 속의 속성값들의 메모리 주소까지는 내가 신경쓰긴 싫어~

대체 불변성이 무엇이길래?? 불변성이 뜻하는게 뭔지 알아보도록하자.

### 불변성이란

불변성 단어 그자체로 보자. 변하지 않는다는 뜻이다. 프로그래밍에선 데이터의 원본이 바뀌지 않는것이라고 말할수있다.

이전에 변수가 선언될때 메모리에 관해 살짝 다룬 적이있다. [let,const 선언과 메모리모델](https://erurang.github.io/web/2021/05/03/js-memorymodel/) 읽고오면 이런느낌의 글이겠구나 생각하고 볼수있을거같다.

var는 재선언이 가능하고 const는 재선언이 불가능하다는것을 위의 글을 읽고왔으면 우린 알수있다.

자 아래의 그림을 통해 불변성을 지켜야 하는 경우를 생각해보자..

### 불변성을 지켜야 하는 이유

![스크린샷 2021-05-06 오후 2 11 19](https://user-images.githubusercontent.com/56789064/117244962-f08ace00-ae74-11eb-91f4-dea575ea259e.png)

`{}==={}`의 결과는 false라는것을 먼저 알아두고가자. 객체는 생성시에 다른 메모리 주소에 생성이 된다.

![스크린샷 2021-05-06 오후 3 00 08](https://user-images.githubusercontent.com/56789064/117248971-c1c42600-ae7b-11eb-9557-8f8017a567df.png)

1. o1 변수는 {name:'kim'}이라는 속성을 메모리에 올려놓았다.
2. o2 변수는 {name:'kim'}이라는 속성을 다른 메모리에 올려놓았다.
3. o3 변수는 o1과 같다 라고 선언하였다. 고로 o3는 o1의 메모리주소와 같다 (o1 === o3)

![스크린샷 2021-05-06 오후 3 01 12](https://user-images.githubusercontent.com/56789064/117249048-e8825c80-ae7b-11eb-83a7-2133f91a5522.png)

4. 여기서 o3.name = 'lee' 라고 바꾸었다.

여기서 일어날수 있는 문제를 생각해보자. o2는 아무 문제가 없다. 하지만 o1과 o3는 같은 메모리주소를 공유하였고,

o3에서 기존 객체의 속성값을 변경을 시켰다. 하지만 o3의 값을 변경시켰는데 o1이 가르키고잇던 속성까지 변해버린것이다.

이게 의도한것이라면 상관없지만.. 의도치않게 다른값까지 변경시켜버렷으니..

o1에게 영향을 주지않고 o1의 속성을 가지면서 o3만 값을 변경시킬 방법은 없을까?

### 단순속성일 경우 불변성을 지키기

그 방법이 `Object.assign({},o1)` 이다. 빈객체에 o1의 속성값을 복사해서 넣겠습니다 라고 해석하면 된다.

![스크린샷 2021-05-06 오후 3 02 01](https://user-images.githubusercontent.com/56789064/117249116-051e9480-ae7c-11eb-86b9-44c0a2264289.png)

자 위의 결과처럼 o4는 o1과 같은 {name: 'hijk'}를 가지게 된것을 볼수있다.

여기서 o4의 name을 test로 변경해보자.

![스크린샷 2021-05-06 오후 3 03 47](https://user-images.githubusercontent.com/56789064/117249273-43b44f00-ae7c-11eb-9eee-b7776010fe27.png)

o4의 속성값을 변화시켰는데 o1의 속성값은 hijk 그대로인것을 볼수있다. 왜냐면 o4는 o1과 생성때부터 다른 메모리 주소를 가지고 있기 때문이다. 그것이 o1 === o4 가 false로 나타나는 이유다.

자 이렇게 한객체에 단일속성만 있을때는 이렇게 처리 된것을 볼수가 있다. 만약에 속성안의 속성 속성... 일때는 메모리에 어떻게 남아있는지 그림으로 보자.

### 속성안의 속성..일 경우 불변성을 지키기

Object.assign() 으로 큰틀에서 같은 속성값을 가진 다른 메모리 주소를 만드는데는 성공했다. 불변성을 지켯다고 할수있다.

![스크린샷 2021-05-06 오후 3 39 24](https://user-images.githubusercontent.com/56789064/117252654-3d74a180-ae81-11eb-894e-62805cfe749c.png)

하지만 그 안의 속성중 어떠한 값이 object라면 assign은 안의 값을 복사해서 가져오는게 아니라 그 오브젝트의 메모리 주소를 복사해온다.

비유하자면 겉은 분명히 101호 102호 다른집이지만 101호와 102호가 아직도 연결이 되있다는 것이다. 즉 불변성을 못지킨 상태라고 할수있다.

### 만약 배열일경우

![스크린샷 2021-05-06 오후 3 43 07](https://user-images.githubusercontent.com/56789064/117253076-c25fbb00-ae81-11eb-8f4b-ea39d152363d.png)

위와같이 객체를 복사하였으나 우리가 o2.score에 3의 값을 push 하였는데 o1.score에도 3의 값이 push 된것을 볼수있다. o1은 o2로 인해서 값이 변화된것이다. 불변성을 지켯다고 할수 없다.

그럼 어떻게해야할까? push를 하기 전으로 돌아가서, `o2.score = o2.score.concat()`을 해준다.

![스크린샷 2021-05-06 오후 3 46 19](https://user-images.githubusercontent.com/56789064/117253474-35693180-ae82-11eb-8892-8e824e314ad4.png)

이 뜻은 무엇인가? 일단 객체를 다른 메모리 주소에 복사하는것은 성공했다. 그 다음에 새 concat을 이용해 배열을 복제하는것이다.

원래 concat은 기존 배열에 다른 배열을 합칠때 쓰는 함수인데 우리는 인자로 아무것도 넘기지 않았으니 처음 복사한 객체를 그대로 복제해 다른 메모리에 올려놓은 효과를 얻게 된것이다.

이로써 o2와 o1은 서로 완전 독립되었고 불변성을 지켰다고 말할수있다. 왜 Object.assign은 써서 복사하지는 않나요? 할수있는데 이렇게 복사하게되면 배열의 기본 함수들을 사용하지못하게된다.

![스크린샷 2021-05-06 오후 3 51 29](https://user-images.githubusercontent.com/56789064/117254080-eec80700-ae82-11eb-99c1-465421fc51d9.png)

push를 한후 concat을 하기전과 후의 차이를 볼수있다.

### 만약에 {} 일경우

![스크린샷 2021-05-06 오후 4 08 49](https://user-images.githubusercontent.com/56789064/117256203-597a4200-ae85-11eb-9261-fdfb65e6a876.png)

spread 연산자를 사용하거나 object.assign()을 통해 불변성을 지켜줄수있다.
