---
layout: post
title:  "mutable immutable"
subtitle: "mutable immutable"
categories: web
tags: javascript
comments: true

---

### 변경가능과 변경불가능에 대해 알아보자.

나는 이것을 string = '' 문자열을 직접 제어할때. 왜 이게 안되지?? 하는 생각에 찾게 되었다. 사건의 발단은 다음과 같다.

```
//Python

// 1

a = [1,2,3,4,5]
a[0] = 3
a = [3,2,3,4,5]

// 2 
a = '12345'
a[0] = 3 // 삐삑!!
```

1번에서 우리가 리스트를 수정했듯이 각 요소를 []로 고쳣듯이 문자열도 []로 접근해서 수정하면 되지않을까? 하는 생각이였다.

그런데 큰오산이였다. 왜냐.. 오류가 떳거든.. 그럼 C처럼 문자마다 1바이트씩 메모리에 선언되는 경우에는 저렇게 수정을 할수있을까? 정답은 되지않는다. 왜냐하면 문자열 자체가 읽기전용으로 메모리에서 수정을 거부하기때문이다.

즉 자바스크립트 파이썬도 같다. 읽기전용으로 메모리에 올라가기때문에 문자열을 수정을 할수없다. 

자 스트링은 왜 안되고 리스트안의 변수는 왜 수정이 가능할까??

### 원시타입(primitive data type)은 변경 불가능한 값(immutable value)다.

자바스크립트의 원시타입에는 `Boolean null undefined Number String Symbol` 가 존재하고 나머지는 모두 객체타입으로 객체는 모두 변경 가능한 값이다.

즉 변경가능하다는것은 새로 값을 만들 필요없이 직접 변경이 가능하다는 뜻이다. 아래의 예를보고 공부해보자.

```
let str = 'hello'; // 0x1234
str = 'bye'; // 0x2345
```

첫번째 str이 선언되고 나면 메모리에 0x1234란 주소에 문자열 `hello`가 생성된다고 가정해보자. 

두번째 str을 bye로 바꾸게되면 str은 `hello`가 저장된 메모리 주소를 가르키지않고 bye라는 문자를 메모리에 생성해 0x2345를 가르키게된다.

자바스크립트에서는 주소값을 찾는 함수가 안보여서.. 파이썬으로 예시를 들어본다.

```
a = '1234'
b = a

print('a의 변경전 주소 :',id(a))
print('b의 변경전 주소 :',id(b))

a = '2345'

print('a의 변경후 주소 :',id(a))
print('b의 변경후 주소 :',id(b))
```

우리는 a를 선언하고 b가 a와 같은 메모리주소를 가르키도록 만들었다. 그후에 a의 값을 바꿧다. 우리는 위에서 기존 선언된 문자는 유지한채로 다른 메모리주소에 선언되어 

그 주소를 새로 가르키게 된다고 하였다. 그럼 아래의 결과를 보고 맞는지 확인해보자.

```
a의 변경전 주소 : 4377171888
b의 변경전 주소 : 4377171888

a의 변경후 주소 : 4377171952
b의 변경후 주소 : 4377171888
```

a와 b가 변경전에는 같은 `4377171888`주소를 가르키고있었고 a가 변경된후엔 `4377171952` 주소를 새로가르키게 되었다.
여전히 b는 변경되기전 a주소인 `4377171888` 를 가르키는걸 볼수있다. 즉 기존주소는 메모리에 올려놓은채 새로운 주소를 가르키는게 맞다는걸 볼수있다.

엥 그런데 우리가 문자열일부를 자를떄는 (.slice() , [:]) 왜 작동하는걸까?? 문자열 자체를 수정하는것이 아니라 새로운 문자열을생성해서 반환하고있기 떄문에 가능한것이다.

그래서 위와같은 결과로 우리는 객체는 변경가능한 값으로 직접 대상을 변경가능하고, 문자열은 읽기전용으로 수정이 불가함과 동시에 변경시에는 다른 메모리에 할당이 된다고 배웠다.

그럼 객체끼리는 어떻게 될까? 객체끼리는 불변성을 위하여 Object.freeze / Object.assign / ... 을 이용할수있다.

불변성에 대해선 [불변성(immutability)이 무엇일까??](https://erurang.github.io/web/2021/05/06/js-immutability/) 에 정리해두었다.


