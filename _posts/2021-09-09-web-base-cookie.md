---
layout: post
title:  "State & Cookie & Session"
subtitle: "State & Cookie & Session"
categories: web
tags: base
comments: true

---
## statefull? stateless?

http는 stateless라서 사용자에 맞는 정보를 저장할수가 없다.

하지만 로그인을 하면 그 상태가 계속 유지되는것을 알수있다.

http는 상태를 가지지않는데 (여기서는 로그인이 되었다는 상태로 예를 든다..) 

어떻게 페이지를 이동할때마다 로그인 상태를 유지할수있는것일까?

이 의문을 쿠키와 세션을 담당하고있다.

### cookie

쿠키의 발행방식은 이렇게 이루어진다.

1. 클라이언트에서 서버로 요청을 보낸다.
2. 서버는 요청을 확인하고 서버에서 지정한 정보들을 http header에 cookie(key-value)를 담아 보낸다.
3. 클라이언트는 서버로부터 받은 쿠키를 저장하고, 매 서버 요청마다 헤더에 받은 쿠키를 같이 넘겨준다.

클라이언트에서 서버로 요청하여 받은 쿠키를 사용해서 서버는 사용자를 식별하게된다. 

**즉 클라이언트가 서버 정보를 가지고있다.**

하지만 단점도 존재한다.

1. 보안에 취약하다
   1. 요청 시 쿠키의 값을 그대로 보낸다.
   2. 쿠키를 조작당할 위험이 존재한다.
2. 쿠키에는 용량 제한이 있어서 많은 정보를 담을수 없다
   1. 쿠키의 용량이 커지면 네트워크 자원소모가 심해진다.
3. 브라우저마다 쿠키지원 형태가 다르기떄문에 공유가 불가능하다

이렇듯 쿠키는 접근하여 수정할수있기 때문에 위험이 크다는것을 알수있다.

이 쿠키를 보완한것이 세션이다.

### session

세션의 발행 방식은 이렇게 이루어진다.

1. 클라이언트에서 서버로 요청을 보낸다.
2. 서버는 요청을 확인하고 요청정보를 **서버에 저장**한후 세션아이디를 쿠키에 담아 클라이언트에 보낸다
3. 클라이언트는 받은 세션아이디로 서버와 통신해 사용자를 식별한다.

세션은 서버에 참조할 세션아이디만 가지고있을뿐이지 개인정보를 가지고있지 않기 떄문에

쿠키에 비해 세션이 안전하다고 볼수있다. 

하지만 단점도 존재한다.

1. 각 사용자마다 세션id를 발급하여 서버가 저장하고있다
2. 그렇기때문에 서버에 많은 부하가 올수있다.

### jwt(json web token)

json(object)을 base64을 통해 string형식으로 변환하여 토큰만드는 방식이다.

jwt는 .으로 구분되어있고, 각각 역할을 담당하고있다.

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. // Header

eyJ1dWlkIjoiNjA2N2E2YWUtODIzNy00YmRiLWE0YjEtYjdhNmIwMjA1YTlkIiwiaWF0IjoxNjMxMDkxNzgyfQ. // Payload

RYp6E6HxAchDmj6FfvGA422D0PYkw4Z8na8CQZkwUQ // Signature
```

## Header
   1. alg : 암호화할 해싱 알고리즘
   2. type : 토큰의 타입

## Payload
   1. 서버에서 정보를 담는곳
   
## Signature
   1. 인코딩된 header와 payload를 더한뒤 비밀키(우리가 지정가능)로 해싱하여 생성됨
   2. 서버에서 관리하는 비밀키가 유출되지 않는 이상 복호화할 수 없다.
   3. 토큰의 위변조 여부를 확인하는데 사용됨

jwt는 아래와 같은 절차로 만들어지고 인증처리를 한다.

1. 클라이언트에서 서버로 정보를 넘긴다
2. 서버는 정보가 올바른지 확인후에 jwt로 변환하여 클라이언트에게 전달한다
3. 이후 모든 클라이언트 요청에서 서버에서 받은 jwt를 헤더에 포함하여 보낸다.
4. 서버는 클라이언트 요청을 통해 받아온 jwt를 매번 검증하여 유효성 검사를 한다

이렇듯 jwt는 세션과 달리, 서버에서 상태를 저장하지않는다.

하지만 단점도 존재한다.

1. 유효기간 만료기간을 잘 설정해야한다.
   1. jwt의 만료기간이 무한일때 해커는 모든 경우의 수를 통해 비밀키를 알아내어 jwt를 해독할 가능성이 있다.
2. 위와 같은 단점을 해결하기위해 accessToken 기간을 짧게하고 refresh token을 새로 발급하는 방식이 있다.
3. Payload 는 따로 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인할 수 있다.
