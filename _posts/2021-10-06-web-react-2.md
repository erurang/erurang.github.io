---
layout: post
title:  "useState는 어떻게 작동할까?"
subtitle: "useState는 어떻게 작동할까?"
categories: web
tags: react
comments: true

---

## useState는 어떻게 상태를 저장하고있나?

`Class`방식이 아닌 `React hook`에서 컴포넌트가 상태를 관리하는 방법이다.

이 글의 시작은 다음과 같은 의문으로 부터 시작한다.

1. useState로 컴포넌트가 각 상태를 가진다
2. const로 선언된 상태를 어떻게 변화시키는것인가?
3. 상태를 가진 컴포넌트가 re-render가 될때 컴포넌트 내부에 선언된 useState 변수는 기존값을 어떻게 유지하나?

위의 의문을 해결해보기위해서 하나씩 만들어가보자

## useState 만들어보기

리액트에서 컴포넌트에서 생성하는 방식대로 한번 만들어보자면 아래 코드일것이다.

```
/** HTML **/
<div id="app"></div>

/** Javascript **/
function useState(initState) {
  let state = initState; 
  const setState = (newState) => {
    state = newState; 
    render(); 
  };
  return [state, setState];
}

function Counter() {
  const [count, setCount] = useState(1);

  window.increment = () => setCount(count + 1);

  return `
        <div>
        <span>${count}</span>
        <button onclick="increment()">증가</button>
        </div>
        `;
}

function render() {
  const $app = document.querySelector("#app");
  $app.innerHTML = Counter();
}

render();
```

하지만 우리코드는 버튼을 눌러도 상태값인 `1`의 값이 변경되지 않을것이다. 왜냐? `Counter()`를 실행할떄마다 `render()`가 재 실행되며

`useState`의 `initialState`는 `1`로 다시 선언되어서 다시 만들어지기 때문이다. 이 상태값을 갱신하려면 어떻게해야할까?

생각을해보면 `useState`는 선언은 컴포넌트 안에서 하지만 상태변수 관리는 외부에서 해야한다는것을 알수있다.

```
let state = undefined;

function useState(initState) {
  if (state === undefined) {
    state = initState;
  }

  const setState = (newState) => {
    state = newState;
    render();
  };
  return [state, setState];
}
```

그래서 `useState` 코드를 위처럼 외부에 상태값을 만들도록하면 외부에서 상태값을 가져와 갱신시키때문에 값을 유지할수있다는걸 알수있다.

<!-- 그런데 생각해보자. 자바스크립트에는 `클로져(closure)`라는 기능이 있다는것을.

[자바스크립트 Conext와 Clousre에 대해서](https://erurang.github.io/web/2022/01/30/js-closure/) 이 글을 참고하길 바란다. -->

## 이전 상태와 비교하여 상태 업데이트

리액트는 상태를 기준으로 컴포넌트를 업데이트하는데 위 코드의 `useState`는 무조건 `render()`가 실행되도록 설정되어있다.

이전 상태와 비교해서 필요할때만 `render()`를 하도록 코드를 수정해보자.

```
function useState(initState) {
  if (state === undefined) {
    state = initState;
  }


  const setState = (newState) => {

    if(state === newState) return
    if(JSON.stringify(state) === JSON.stringify(newState)) return

    state = newState
    render();
  };
  return [state, setState];
}
```

물론 리액트에서는 위 코드랑 똑같은 로직은 아니겠지만.. (리액트는 [Shallow Comparison에 대하여](https://erurang.github.io/web/2021/05/06/js-spread2/)로 렌더링을 한다)

## useState에서 상태가 바뀌면 render가 일어난다

즉 `useState`와 `rendering`은 떌래야 떌수가 없는 관계이다. 

~~업데이트예정

<!-- 
## useState 테스트

```
import { useState } from "react";

function App() {

  const [state, setState] = useState(0);

  function handler() {
    console.log("state :", state);
    setState(1);

    if (state === 1) {
      console.log("버튼을 누르면 바로 실행이 될까?");
    }
  }

  console.log('App 컴포넌트 렌더링!');
  return (
    <div className="App">
      <button onClick={() => handler()}>버튼</button>
    </div>
  );
}

export default App;
```

위의 코드를 실행한후에 버튼을 한번 누른다면 콘솔에는 어떤 결과가 출력될까?

```
state : 0 , 버튼을 누르면 바로 실행이 될까?

state : 0
```

위와 아래중 어떤것이 콘솔의 결과에 나타날까?? 정답은 2번이다

<img width="209" alt="스크린샷 2021-10-19 오후 3 01 24" src="https://user-images.githubusercontent.com/56789064/137852465-ab5e35ef-6a31-46d5-8db9-c65251ee6bad.png">

어 이상하다.. 분명히 버튼을 누르지 않았을때는 숫자 `0`인 상태로 시작햇을것이고 `setState(1)` 코드를 만나서 `state`가 `1`로 바뀐뒤

`if(state===1)`이 `true`이기 때문에 한번 버튼을 눌러도 `"버튼을 누르면 바로 실행이 될까?"` 가 출력됬어야하는데 말이다.

## useState 테스트2

한가지 더 테스트를해볼까?

```
import { useState } from "react";

function App() {
  
  const [count, setCount] = useState(0);


  function handler() {
    setCount(count + 2); // 2번
    setCount(count + 1); // 1번
  }

  console.log("App 컴포넌트 렌더링!");

  return (
    <div className="App">
      <h1>{count}</h1>
      <button onClick={() => handler()}>버튼</button>
    </div>
  );
}

export default App;
```

위 코드에서 `setCount`를 통해 상태를 2번 변경시킨다. 이때 버튼을 한번 클릭한다면 `count`는 `2`가될까 `1`이될까 아니면 `3`이될까?

<img width="355" alt="스크린샷 2021-10-19 오후 3 52 15" src="https://user-images.githubusercontent.com/56789064/137858466-32df446a-d15c-4aa1-9b12-a1e01cb1f4ef.png">

처음 컴포넌트가 렌더링될때 `0`, 버튼을 누른후 렌더링이 다시 일어나고 `1`로 변한것을 볼수있다. 

`useState`는 초기값 `0`에서 1번째 `setCount`를 통해 `[2,setCount]`를 반환 받고, 2번쨰 `setCount`에서 `[1,setCount]`를 돌려받은 것이라고 예상할수있다.





큐에 순서대로 들어가 상태가 변화되는 코드를 merging하여서 새 상태를 만든다. 이것을 오브젝트 컴포지션이라한다.

```
const newState = Object.assign(currentState, {count : count+ 2}, {count : count+ 1})
```

즉 setCount()를 통해 상태가 변경되는 모든 과정이 뒤의 setState()로 변경한 객체들을 합친다. (같은 속성을 가질때는 뒤에 위치한 객체의 값으로 덮어쓴다.) 

그리고 newState로 만들어진 하나의 결과값으로 딱 한번 렌더링이 일어난후에 업데이트된 상태를 볼수있다. 

Object.assign에 대해서는 [https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) 이곳에서 공부할수있다.

## useState() 사용해보기 3 함수적 갱신방법

그렇다면 상태값을 캐치하먄서 동기적으로 변경시키려면 어떻게 해야할까? 값을 전달하는게아니라 함수를 전달하면 된다.

함수이기 때문에 따로 오브젝트 컴포지션을 하지 않고 호출된 순서대로 큐에 넣고 큐에 넣어진 대로 함수를 실행하기 때문에 동기적으로 상태변경이 이어지게된다.

```
import { useState } from "react";

function App() {
  console.log("App 컴포넌트 렌더링!");

  const [state, setState] = useState({
    wait: false,
    payment: false,
    ok: false,
  });

  const [count, setCount] = useState(0);

  function handler() {

    // 1번
    setCount(prev => prev +1)
    setCount(prev => prev +1)
    setCount(prev => prev +1)
    
    // 2번
    setState((prev) => ({ ...prev, wait: true }));
    setState((prev) => ({ ...prev, payment: true }));
    setState((prev) => ({ ...prev, ok: true }));
  }

  console.log(state);

  return (
    <div className="App">
      {count}
      <button onClick={() => handler()}>결제하기</button>
    </div>
  );
}

export default App;
```

<img width="335" alt="스크린샷 2021-10-19 오후 7 29 48" src="https://user-images.githubusercontent.com/56789064/137892405-e741eb55-cf98-49aa-a160-6d33ddd7e2c5.png">

아래처럼 수정해서 현재 prev가 어떻게 작동하는지 한번 알아보자.

```
import { useState } from "react";

function App() {
  const [state, setState] = useState({
    wait: false,
    payment: false,
    ok: false,
  });

  const [count, setCount] = useState(0);

  function handler() {
    console.log("count시작:", count);

    setCount(1);

    setCount((prev) => {
      console.log("prev1: ", prev);
      return prev + 1;
    });

    setCount((prev) => {
      console.log("prev2: ", prev);
      return 3;
    });

    setCount((prev) => {
      console.log("prev3: ", prev);
      return prev + 1;
    });

    // setCount(count); 5번

    setState((prev) => {
      console.log("prev4 : ", prev);
      return { ...prev, wait: true };
    });
    setState((prev) => {
      console.log("prev5 : ", prev);
      return { ...prev, payment: true };
    });

    // setState({ ...state }); 6번

    setState((prev) => {
      console.log("prev6", prev);
      return { ...prev, ok: true };
    });
  }

  console.log("App 컴포넌트 렌더링!", count, state);

  return (
    <div className="App">
      {count}
      <button onClick={() => handler()}>결제하기</button>
    </div>
  );
}

export default App;
```

<img width="449" alt="스크린샷 2021-10-19 오후 8 32 31" src="https://user-images.githubusercontent.com/56789064/137901108-ce5f34ad-2fda-404e-8acb-55993c29bb6a.png">

처음 숫자가 1로 지정된후에 prev1 에는 1이 출력되는걸 볼수있다. (이미 ReactDispatcher.value의 값이 저렇게 설정되있다는 얘기임)

그다음으로 prev2에는 2가 들어온것을 확인할수있다. 다음으로 숫자 3을 리턴하여서 다른값으로 변경시켯다. 자 다음엔 어떤 값이 들어갈까?

prev3에는 그전의 상태 3이 나타나는것을 볼수있다. 마지막으로 3에 1을 더하여 최종값 4가 리턴이된후에 상태변경을 마치고 App이 리렌더링되어 숫자 4가 화면에 나타나게된다.

state의 경우에도 마찬가지다. state가 prev로 작동하면서 이전의 변경상태를 그대로 가지고와서 후의 상태를 포함하여 변경시킨다.

### 만약에 5번과 6번코드가 있었다면 값이 어떻게 변할까?

<img width="459" alt="스크린샷 2021-10-19 오후 8 34 43" src="https://user-images.githubusercontent.com/56789064/137901408-d25ab01b-ff19-40f3-822b-c1f6d31f500f.png">

기존에 앞에서 변하던 값들의 상태가 다 무시된다. 

왜냐하면 우리가 가져온 `{...state}`와 `count` 상태는 아직 렌더링이 되기전( 상태값이 갱신되기전 initialState) 에서 값을 변경을 시켰기때문이다.

그래서 우리는 값을넣는 방식보다 `(prev =>)` 이전값을 가져와서 갱신하는 방식으로 상태를 갱신해야만 우리가 생각한대로 작동한다는것을 알수있다.


## 그럼 왜 리액트팀은 useState를 비동기적으로 작동하게 만들었을까?

여기서 위와같은 의문이생긴다. 왜 동기적으로 작동을할수도있는데 비동기적으로 작동하게 만들었을까?

만약에 여러 상태를 한번에 변화시킬 일이 필요할때 리액트는 하나의 상태가 업데이트될떄마다 매번 화면을 렌더링하게된다. 

효율을 높이기위해 여러 상태변경 요청을 합친후에 하나의 상태(값)로 만든후 한번 렌더링 하도록 만들었다고 할수있다.











![스크린샷 2022-06-02 오후 9 47 09](https://user-images.githubusercontent.com/56789064/171632488-b79d4adc-0d8f-43dd-b1d0-752208fd1fb2.png)

`useState`의 첫번째요소로 최초의 상태값을 받고, 두번째 요소로 이전 상태를 갱신할 새로운 상태를 


그런데 `const` 상수로 선언된 `state`를 어떻게 변경시키는걸까??

알아보기위해 useState가 선언된 파일로 찾아가보자.

![스크린샷 2021-10-19 오후 1 16 59](https://user-images.githubusercontent.com/56789064/137842980-002b3439-2652-49b5-a9a6-92df7d824456.png)

`useState`는 `dispatcher`를 생성후 인자로 초기상태값을 받아 `dispatcher.useState`에 전달하는것을 볼수있다.

즉 `resolveDispatcher` 안에 `state`와 `setState`가 존재한다는것이다. `resolveDispatcher` 함수정의를 보자.


![스크린샷 2021-10-19 오후 1 43 20](https://user-images.githubusercontent.com/56789064/137845361-379d8c86-aca9-45ba-8d9d-bbb4414eacb6.png)
)

이번엔 또 `ReactCurrentDispatcher` 라는 곳에서 값을 가져오는걸 볼수있다.. 이번엔 `ReactCurrentDispatcher` 이친구를 따라가보자

![image](https://user-images.githubusercontent.com/56789064/137845770-8267f849-2854-484c-9338-9f423afabf2f.png)

즉 `ReactCurrentDispatcher`는 전역으로 선언된 객체이고, 객체안 속성으로 current를 가지고있는것을 볼수있다.

자.. 한번 정리를 해보자.

1. useState(... 등등 hooks) react모듈에 선언되어있는 함수다
2. 실행될때마다 dispatcher를 선언하고, useState 메소드를 실행하고 값을 반환한다.
3. 이 dispatcher는 전역변수 ReactCurrentDispatcher로 부터 가져온다.

즉 함수가 선언부보다 상위에 있는 값에 접근하는것. Closure를 이용하고있다. 위의 코드를 하나하나 파헤쳐보면.

1. App이 실행되고 인수로 0을 전달한다.
2. useState는 내부적으로 구현된 current 값을 확인한다
   1. 초기값이 할당되지 않은 상태면 초기값을 할당한다
3. 버튼을 누르면 현재시점의 값을 업데이트한다 (setState(1)로 0 -> 1)
4. `[count,setState]`를 반환후 컴포넌트를 리렌더링 시킨다

위와같은 로직을 통해서 컴포넌트의 렌더링이 일어난다고 할수있다.



`useState()`로 선언된 초기 상태값은 리액트 내부에 변수로써 저장이 되어있다.
`setState()`함수를 호출하면 useState()의 내부 변수에 내부에 저장된 state값에 setState()를 한 결과를 리턴해주는것이다. 
내가 말을 잘 못해서 이해가 어려울수있는데.. 아래 예시로 한번더 시험해보자. -->