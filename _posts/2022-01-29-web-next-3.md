---
layout: post
title: "Nextjs SSR 사용"
subtitle: "Nextjs SSR 사용"
categories: web
tags: nextjs
comments: true
---

## NextJS에서 SSR 사용하기

### 만약 서버사이드 렌더링을 사용하지 않으면..?

```
import { useState, useEffect } from "react";

export default function Home() {
  const [title, setTitle] = useState("");

  useEffect(() => {
    new Promise((res, rej) => {
      setTimeout(() => {
        res("제목이 날라왔어요~");
      }, 3000);
    }).then((title) => setTitle(title));
  }, []);

  if (title === "") return <h1>로딩중...</h1>;

  return (
    <div>
      <h1>{title}</h1>
    </div>
  );
}
```

간단히 `api`를 호출했다고 가정하고 제목을 받아와 UI에 제목을 표시해주는 함수가 있다고 해보자.

위 방식은 `CSR`방식으로 작동한다. `CSR`방식에서는 데이터를 불러오는동안 `Loading` 을 사용하여 UI표현후 받아온 데이터를 그리는 방식이다.

![스크린샷 2022-01-29 오전 2 48 41](https://user-images.githubusercontent.com/56789064/151596566-4bd53428-a19c-4c18-9f7b-c61e723f9e11.png)

이 페이지를 서치엔진이 접근 했을때 볼수있는 HTML은 `<h1>로딩중...</h1>` 뿐인것을 볼수있다.

브라우저가 `API`를 호출하고 값을 받아 UI를 동적으로 만들어내기 때문이다. 그럼 `SSR` 방식으로는 어떻게 사용할수 있을까?

### 서버사이드렌더링을 사용한다면?

`SSR`로 페이지를 만들고자 하는 파일에 `getServerSideProps` 이름으로 함수를 하나 만들어준다

```
export default function Home({ title }) {
  console.log(new Date());
  console.log("컴포넌트", title);

  return (
    <div>
      <h1>{title}</h1>
    </div>
  );
}

export async function getServerSideProps() {
  const title = await new Promise((res, rej) => {
    setTimeout(() => {
      res("제목이 날라왔어요~");
    }, 3000);
  });

  console.log(new Date());
  console.log("서버", title);
  return {
    props: {
      title,
    },
  };
}
```

`SSR` 방식으로 `getServerSideProps()` 함수 내에서 리턴한 값을 컴포넌트에서 사용할수있다.

위의 방식은 로딩이 필요하지 않다. 왜냐하면 `Server`에서 `HTML`을 모두 만든후에 `Client`로 전달해주는 `SSR`방식이기 때문이다.

<img width="391" alt="스크린샷 2022-01-29 오전 2 46 56" src="https://user-images.githubusercontent.com/56789064/151596316-32a215d9-e844-4acb-8fae-92c87b2dec4b.png">

위의 예시에서는 3초뒤에 서버에서 값을 받아서 `UI`에 그리기 때문에, 브라우저(client)는 3초간 빈 화면을 보게 된다.

![스크린샷 2022-01-29 오전 2 47 50](https://user-images.githubusercontent.com/56789064/151596448-323c5e5c-0b5d-44e6-9063-0705b6d48223.png)

서버에서 전달받은 `HTML`이 브라우저에 나타난것을 볼수있다.

하지만 단점도 존재한다. `SSR`은 매번 해당 페이지에 접근할때 모든 `Server`에서 모든 화면을 만든후 `HTML`로 넘겨주는 과정으로 인해

서버에서 `HTML`을 주는 시간까지 사용자는 흰 화면을 보게된다. 그리고 매번 `SSR`로 만들어진 `URL`로 접속할시에는 매번 서버에 요청하게된다.

`CSR`과 `SSR`를 선택하여 사용할때 `SEO`가 필요한가? 를 기준으로 사용하는것이 좋을것이다.
