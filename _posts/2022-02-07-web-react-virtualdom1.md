---
layout: post
title:  "리액트의 Virtual DOM"
subtitle: "리액트의 Virtual DOM"
categories: web
tags: react
comments: true

---

## 리액트의 필요성을 느낀 시점

리액트의 필요성을 느낀건 DOM관리였다. 나는 아래 기능을 만들려고 ajax를 통한 dom업데이트를 구현하려고 했다.

1. 댓글을 등록하면 화면에 바로 적용되도록 (DOM 업데이트) 
2. 좋아요/싫어요 를 클릭하면 화면에 바로 적용되도록 (DOM 업데이트) 

프론트에서 버튼을 누르면 서버에 api를 날리고. 서버의 상태코드에 맞춰서 화면을 업데이트하도록 구현했다.

이 과정에서만 나는 DOM querySelector를 수도없이 많이썻다. DOM조작을 위해서 querySelector를 매번 사용하는것이 불편했다.

DOM의 상태가 변화되면 자동적으로 DOM을 업데이트해주는 리액트가 이떄 생각이 났다.

## DOM관리를 알아서 해준다?

1. DOM에 변화가 일어난다.
2. 어떤 방식으로 DOM을 가져와서 화면을 업데이트할까?
   1. 기존처럼 DOM을 선택해서 일일이 수정하는 방법..?

리액트를 만든 페이스북 팀은 위와같은 고민을 이렇게 해결했다.

```
아예 컴포넌트를 날려버리고 새로만들어버리자!
```

하지만 기존의 DOM방식처럼 DOM을 날려버리고 새로 만들어버리면 성능적으로 엄청난 문제가 일어난다고 생각했다.

그래서 리액트팀은 가상돔을 생각하게 되었다. **Virtual DOM은 애플리케이션의 UI를 구성하는 HTML 엘리먼트를 메모리 내에서 구현한 것이다**.

1. DOM에 변화가 일어난다
2. DOM과 가상DOM을 비교해 변경된 부분만 렌더링을 한다

DOM에 변화가 일어났을때 DOM을 바로 업데이트 하는것이 아니라 **메모리에 보관된 가상 DOM에** 변경된 부분만 찾아서 바꿔주는것이다.

그런데 성능적으로 문제라는게 얼마나 큰 차이길래 리액트는 가상 돔을 사용할까??

### 브라우저의 작동과정

일단 DOM Tree가 어떻게 생성되는지부터 알아보자.

```
                               DOM
                                ⬇️
    HTML   => HTML Parser => DOM Tree            Layout
                                ⬇️                  ⬇️
                            Attachment     => Render Tree => Painting => Display
                                ⬆️
stylesheet => CSS parser => style Rules
```

1. 브라우저가 HTML 을 받으면 브라우저는 HTML을 파싱하고 DOM(Node)로 이루어진 DOM Tree를 만든다.
2. 외부의 Css 파일과 각 엘리먼트의 스타일을 파싱한다.
   1. HTML CSS Parser를 통해서 Object Model로 만든다. 
3. DOM Tree와 CSSOM Tree를 합쳐서 스타일을 적용하여 새로운 Render Tree를 생성한다
   1. display:none 같은 속성은 화면에서 어떤 공간도 차지하고있지않아 렌더트리에서 제외된다
4. Render Tree가 다 만들어지고나면 Layout(reflow)를 통해서 각 노드들이 화면에서 위치할 위치(좌표)와 크기를 계산한다.
5. Render Tree에서 계산된 요소들을 사용해 브라우저는 화면에 요소들을 그린다.

이제 기존의 DOM이 화면을 업데이트 할때는 위와같은 과정을 항상 거쳐온다고 생각해야한다.

DOM이 변화되면~ 모든 요소들의 스타일을 다시 계산하고~ 돔트리를 다시만들고~ 렌더트리를 생성하고~ 레이아웃을 만들고~ 그리고~ 표시하고~

엄청난 리소스가 필요하단걸 알수있다.

### 그래서 Vitual DOM이 뭔데?

**Virtual DOM은 애플리케이션의 UI를 구성하는 HTML 엘리먼트를 메모리 내에서 구현한 것이다**.

리액트는 실제 DOM에 바로 업데이트하는것이 아니라 가상 DOM에 먼저 업데이트를 한뒤 최종적 결과만을 실제 DOM으로 전달하여

브라우저가 DOM Tree를 만드는 과정을 줄여 성능 개선 효과를 얻어오기위해 사용한다는 것을 알수있다.

가상 DOM은 원래 DOM의 복사본으로 생각할 수 있다. 이 복사본은 DOM API를 사용하지 않고도 자주 조작하고 업데이트할 수 있다. 


1. DOM의 한번의 변화가 일어나면 한번의 레이아웃 계산과 렌더링을 하고, 10번이면 10번, 20번이면 20번.. 계속되는 렌더링을 만들어낸다.
2. 그래서 실제의 DOM과 똑같은 리액트의 가상돔에 변화된 부분을 적용만 한다 (렌더링을 하지않음) => 레이아웃(리플로우) 페인팅이 이뤄지지않음
3. DOM의 변화가 이루어질때마다 렌더링을 하는것이 아닌 DOM의 모든 변화가 적용된 후 더이상 변경되는 점이 없을때 가상 DOM을 기준으로 DOM을 화면에 렌더링을 한다.
4. 즉 가상돔은 기존의 DOM수정에서 연산과정을 줄여 렌더링을 최소화시킨 것이고 이것이 Virtual DOM을 사용하는 이유라고 할수있다.

즉 virtual dom은 아래의 역할 또한 대신해준다.

DOM fragment를 관리하는 과정을 수동으로 하나하나 작업 할 필요 없다, 자동화하고 추상화 해준다.

즉  이 작업을 직접 한다면, 기존 값 중 어떤게 바뀌었고 어떤게 바뀌지 않았는지 계속 파악하고 있어야한다. (그렇지 않으면 수정 할 필요가 없는 DOM 트리도 업데이트를 하게 될 수도 있음)
