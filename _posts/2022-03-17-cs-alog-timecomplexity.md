---
layout: post
title:  "알고리즘의 효율성과 Big O"
subtitle: "알고리즘의 효율성과 Big O"
categories: cs
tags: algorithm
comments: true

---

## 알고리즘의 효율성

알고리즘이 효율적인지 알기위해서는 수행시간이 가장 중요하다고 할수있다.

알고리즘의 수행시간이 길다(오래걸린다)면 효율적이지 못하다고 말할수있다.

우리는 알고리즘의 효율성을 판단하기위해서 Big O 표현식을 사용하는것으로 약속하였다.

## Big O

Big O는 시간이 가장 오래 걸릴때를 표현한다. 즉 **최악의 경우**를 판단하게 된다.

예를들어 10가지의 경우중 9가지는 1초만에 해결이되고, 1가지가 100초만에 해결이 된다면. 

이때의 시간복잡도(Big O)는 최악의 경우인 100초가 되어 `O(100)` 으로 표현하게 된다.

## 알고리즘에서 시간을 체크하기위해..

알고리즘 문제의 경우 입력된 N(...등등)의 크기를 통해서 시간복잡도를 계산하여 문제 풀이에 도움을 얻을수 있다.

만약에 1부터 N까지 더하는 코드를 실행한다고 해보자.

```
sum =0;
for i in range(1,N+1):
    sum += i
```

위 코드의 시간복잡도는 무엇일까? 1부터 ~ N까지의 수를 다 보면서 더해나가야되기때문에 결국 수를 N번 봐야하기 때문에 O(N)이다.

```
sum = 0;
sum = N(N+1)/2
```

위의 값과 같지만 한번에 계산이 가능한경우는 O(1)로 표현한다.

```
sum = 0;
for i in range(1,N+1):
    for j in range(1,N+1):
        if(i==j) sum += j
```

이 코드는 어떨까? 일단 위의 for문에서 N번을 봐야하는데, 아래의 for문에서도 N만큼 보게된다.

그럼 1/1~N 2/1~N 3/1~N 4/1~N 5/1~N 6/1~N ... N/1~N 을 보게된다.

즉 N*N으로 O(N^2)으로 표현할수있다.

### 알고리즘의 N의 크기에 따라 코드를 어떻게 짤지를 고민할수있다.

모든 언어에서 대부분 1초에 1억정도의 연산을 처리한다고 생각하면 된다.

위 1번 코드에서 N의범위가 1억까지라면 1초만에 실행이 가능한 코드.

위 3번 코드에서 N의 범위가 1만까지라면 1초만에 실행이 가능한 코드가 된다.

만약 3번의 범위가 1만이 넘어가는데 시간제한이 1초라면, 우리는 O(N^2)의 형식으로는 문제를 풀수없다는것을 판단할수있다.

### 시간제한 1초안에 가능한 시간복잡도

```
O(1)
O(logN)
O(N) < 1억
O(NlogN) < 500만
O(N^2) < 1만
O(N^3) < 500
O(2^N) < 20
O(N!) < 10
```

앞으로 알고리즘 문제를 풀때에 문제에 주어진 변수의 크기를 보고 문제를 어떻게 풀어나가야할지 생각하여야 할 것이다.